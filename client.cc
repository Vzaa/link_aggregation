#include <iostream>
#include <stdio.h>           // perror()
#include <string.h>          // bzero(), memcpy()
#include <unistd.h>          // close()
#include <stdlib.h>          // exit()

#include <linux/if_packet.h> // AF_PACKET
#include <net/ethernet.h>    // ETH_P_IP
#include <netinet/ip.h>      // htons()
#include <arpa/inet.h>       // inet_ntoa()

#include <net/if.h>          // Binding a socket to an interface
#include <sys/ioctl.h>

#include <fcntl.h>           // fcntl()

#include <linux/netfilter_ipv4.h>

#include "client.h"
#include "common.h"

Client::Client() {
    /*
     * For the client connection, we want
     *
     *   socket( AF_PACKET, SOCK_DGRAM, htons(ETH_P_IP) )
     *
     * This will yield anything using IP
     */

    /* Prepare socket for client connection */

    struct ifreq ifr;
    struct sockaddr_ll sll;

    // We want IP packets, including headers
    m_socket = socket( AF_PACKET, SOCK_DGRAM, htons(ETH_P_IP) );
//    m_socket = socket( AF_PACKET, SOCK_RAW, htons(ETH_P_IP) );
    if( m_socket == -1 ) {
        perror("socket()");
        exit(1);
    }

    // Get interface index
    memset( &ifr, 0, sizeof( ifr) );
    strncpy( ifr.ifr_name, IFNAME_LOOPBACK, IFNAMSIZ - 1 );
    if ( ioctl( m_socket, SIOCGIFINDEX, &ifr ) < 0 ){
        perror("ioctl()");
        exit(1);
    }
    memset( &sll, 0, sizeof( sll) );
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = ifr.ifr_ifindex;
    sll.sll_protocol = htons(ETH_P_IP);

    // Bind the raw socket to the interface specified
    if ( bind( m_socket, (struct sockaddr *)&sll, sizeof(sll) ) < 0 ){
        perror("bind()");
        exit(1);
    }

    // Make socket non-blocking
    int fdflags = fcntl( m_socket, F_GETFL );
    if( fdflags < 0 ) {
        perror("fcntl()");
        exit(1);
    }
    if ( fcntl( m_socket, F_SETFL, fdflags | O_NONBLOCK ) < 0 ) {
        perror("fcntl()");
        exit(1);
    }

//    m_socket = socket( AF_INET, SOCK_DGRAM, 0 );
//    if( m_socket == -1 ) {
//        perror("socket()");
//        exit(1);
//    }

//    bzero( &m_sockaddr, sizeof( m_sockaddr) );
//    m_sockaddr.sin_family = AF_INET;
//    m_sockaddr.sin_port = htons(4200);
//    m_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);

//    if( bind( m_socket, (struct sockaddr *)&m_sockaddr, sizeof(m_sockaddr) ) < 0 ){
//        perror("bind()");
//        exit(1);
//    }

}

Client::~Client() {
    close(m_socket);
}

Buffer Client::RecvPkt() {
    Buffer buf;

    unsigned char *raw_buf;
    int pkt_len;

    pkt_len = m_nfq_handler.GetPacket(&raw_buf);

    if( pkt_len > 0 ) {
        buf.assign( raw_buf, raw_buf+pkt_len );
    }

    return buf;
}

/*
 * Send a packet to the client.
 * These should be the packets generated by the remote peer,
 * without any changes
 */

int Client::SendPkt( Buffer const & buf ) const {

    int byte_sent;

    byte_sent = send( m_socket, buf.data(), buf.size(), 0 );
    if ( byte_sent == -1 )
        perror("sent()");

//    std::cout << "Send byte to client: " << byte_sent << std::endl;
    return byte_sent;
}
